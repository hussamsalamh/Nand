import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashSet;
// fix for git
/**
 * Created by yonilip on 5/23/16.
 *
 *
 * recursive top-down parser.
 * drives the parsing process in this project
 *
 * Effects the actual compilation output. Gets its input from a
 * JackTokenizer and emits its parsed structure into an output file/stream. The
 * output is generated by a series of compilexxx() routines, one for every syntactic
 * element xxx of the Jack grammar. The contract between these routines is that each
 * compilexxx() routine should read the syntactic construct xxx from the input,
 * advance() the tokenizer exactly beyond xxx , and output the parsing of xxx . Thus,
 * compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
 * In the first version of the compiler, described in chapter 10, this module emits a
 * structured printout of the code, wrapped in XML tags. In the final version of the
 * compiler, described in chapter 11, this module generates executable VM code. In
 * both cases, the parsing logic and module API are exactly the same.
 *
 */
public class CompilationEngine {


    private BufferedReader inputFile;
    private BufferedWriter outputFile;
    private int indentation;
    JackTokenizer jackTokenizer;

    private static final HashSet<Character> opTable = new HashSet<Character>() {{
        add('+');
        add('-');
        add('*');
        add('/');
        add('&');
        add('|');
        add('<');
        add('>');
        add('=');
    }};
    private static final HashSet<Character> unaryOpTable = new HashSet<Character>() {{
        add('-');
        add('~');
    }};




    /**
     * Creates a new compilation engine with the given input and output. The next routine called
     * must be compileClass() .
     * @param inputFile
     * @param outputFile
     */
    public CompilationEngine(BufferedReader inputFile, BufferedWriter outputFile) throws IOException {
        this.inputFile = inputFile;
        this.outputFile = outputFile;
        indentation = 0;

        jackTokenizer = new JackTokenizer(this.inputFile);
        compileClass();
    }

    private void writeScopeOpener(String strToWrite) throws IOException {
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        string += "<" + strToWrite +">\n";
        outputFile.write(string);
        indentation++;
    }

    private void writeScopeCloser(String strToWrite) throws IOException {
        String string = "";
        indentation--;

        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        string += "</" + strToWrite +">\n";
        outputFile.write(string);
    }

    private void writeInScope() throws IOException {
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        JackTokenizer.LexicalElements type = jackTokenizer.tokenType();
        String stringType = jackTokenizer.tokenType().toString();
        if (!stringType.equals("integerConstant") && !stringType.equals("stringConstant"))
        {
            stringType = stringType.toLowerCase();
        }

        //update string according to token type
        switch (type) {
            case KEYWORD:
                string += "<" + stringType +"> " + jackTokenizer.keyWord() + " </" + stringType +">\n";
                break;
            case IDENTIFIER:
                string += "<" + stringType +"> " + jackTokenizer.identifier() + " </" + stringType +">\n";
                break;
            case SYMBOL:
                string += "<" + stringType +"> " + jackTokenizer.symbol() + " </" + stringType +">\n";
                break;
            case stringConstant:
                string += "<" + stringType +"> " + jackTokenizer.stringVal() + " </" + stringType +">\n";
                break;
            case integerConstant:
                string += "<" + stringType +"> " + jackTokenizer.intVal() + " </" + stringType +">\n";
                break;
        }
        outputFile.write(string);
    }

    /**
     * Compiles a complete class.
     */
    public void compileClass() throws IOException {
        writeScopeOpener("class");

        jackTokenizer.advance(); //class
        writeInScope();
        jackTokenizer.advance(); //class name
        writeInScope();
        jackTokenizer.advance(); //open curly
        writeInScope();

        jackTokenizer.advance(); //classVarDec
        while( jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field")))
        {
            writeScopeOpener("classVarDec");
            compileClassVarDec();
            writeInScope(); // ;
            writeScopeCloser("classVarDec");
            jackTokenizer.advance(); // get next for comp
        }
        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                jackTokenizer.keyWord().matches("constructor|function|method"))
        {
            writeScopeOpener("subroutineDec");
            compileSubroutine();
        //    jackTokenizer.advance();
            writeScopeCloser("subroutineDec");
        }
        writeInScope(); // Close curly
        writeScopeCloser("class");
    }

    /**
     * Compiles a static declaration or a field declaration.
     */
    public void compileClassVarDec() throws IOException {
        if (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field"))
        {
            writeInScope(); //field/static
            jackTokenizer.advance();
            writeInScope(); //write type
            jackTokenizer.advance();
            writeInScope(); // write varName
            jackTokenizer.advance();
            compileVarList(); // Compile var list if necessary
        }
    }

    /**
     * Compiles a complete method, function, or constructor.
     */
    public void compileSubroutine() throws IOException {
        if (jackTokenizer.keyWord().matches("constructor|function|method")) {
            writeInScope(); //constructor|function|method

            jackTokenizer.advance(); // void or type
            writeInScope();

            jackTokenizer.advance(); //name
            writeInScope();

            jackTokenizer.advance(); // (
            writeInScope();

            //params list
            jackTokenizer.advance();
            writeScopeOpener("parameterList");
            compileParameterList();
            writeScopeCloser("parameterList");
            writeInScope(); // )


            writeScopeOpener("subroutineBody");
            jackTokenizer.advance(); // {
            writeInScope();
            jackTokenizer.advance();
            while(jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD && jackTokenizer.keyWord().equals("var"))
            {
                compileVarDec();
            }

            compileStatements();

           writeInScope();

            writeScopeCloser("subroutineBody");
           jackTokenizer.advance();

        }
    }

    public void compileVarList() throws IOException
    {
        while (jackTokenizer.symbol() == ',') {
            writeInScope(); //write the symbol
            jackTokenizer.advance(); //next var
            writeInScope(); //write the var name identifier
            jackTokenizer.advance();
        }
    }

    /**
     * Compiles a (possibly empty) parameter list, not including the enclosing ‘‘ () ’’.
     */
    public void compileParameterList() throws IOException
    {
                // Parameter list is empty
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&  jackTokenizer.symbol() == ')')
        {
                return;
        }
        writeInScope(); // write var type
        jackTokenizer.advance();
        writeInScope(); // write var name
        jackTokenizer.advance();
       while (jackTokenizer.symbol() == ',')
       {
            writeInScope(); //write the symbol
            jackTokenizer.advance();
            writeInScope(); //write the var type
            jackTokenizer.advance();
            writeInScope(); // write the var name
           jackTokenizer.advance();
        }
    }


    /**
     * Compiles a var declaration.
     */
    public void compileVarDec() throws IOException
    {
        if (jackTokenizer.tokenType().equals(JackTokenizer.LexicalElements.KEYWORD)
                && jackTokenizer.keyWord().equals("var")) {
            writeScopeOpener("varDec");
            writeInScope(); // write var
            jackTokenizer.advance();
            writeInScope(); // write type
            jackTokenizer.advance();
            writeInScope(); // write varName
            jackTokenizer.advance();
            compileVarList(); // compiles var list if necessary
            writeInScope(); // Should catch ';'
            writeScopeCloser("varDec");
            jackTokenizer.advance();
        }
    }

    /**
     * Compiles a sequence of statements, not including the enclosing ‘‘{}’’.
     */
    public void compileStatements() throws IOException {
        writeScopeOpener("statements");
        //jackTokenizer.advance();
            while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                    jackTokenizer.keyWord().matches("let|if|while|do|return"))
            {

                if (jackTokenizer.keyWord().equals("let"))
                {
                    writeScopeOpener("letStatement");
                    writeInScope(); //write the keyword
                    jackTokenizer.advance();
                    writeInScope(); // write varName
                    jackTokenizer.advance();
                    if (jackTokenizer.symbol() == '[') {
                        writeInScope(); // Write [
                        jackTokenizer.advance();
                        compileExpression();
                        writeInScope(); // Write ']'
                        jackTokenizer.advance();
                    }
                    writeInScope(); // Write =
                    jackTokenizer.advance();
                    compileExpression();
                    writeInScope(); // ;
                    writeScopeCloser("letStatement");
                    jackTokenizer.advance();
                }
                else if (jackTokenizer.keyWord().equals("if")) {
                    compileIf();
                }
                else if (jackTokenizer.keyWord().equals("while"))
                {
                    compileWhile();
                }
                else if (jackTokenizer.keyWord().equals("do"))
                {
                    compileDo();
                }
                else if (jackTokenizer.keyWord().equals("return")) {
                    compileReturn();
                }
            }
        writeScopeCloser("statements");
    }

    /**
     * Compiles a do declaration.
     */
    public void compileDo() throws IOException
    {
        writeScopeOpener("doStatement");
        writeInScope(); // do
        jackTokenizer.advance();
        writeInScope(); // Write name of subroutine
        jackTokenizer.advance();
        compileSubroutineCall();
        writeInScope(); // ;
        jackTokenizer.advance();
        writeScopeCloser("doStatement");
    }

    /**
     * Compiles a let declaration.
     */
    public void compileLet() {

    }

    /**
     * Compiles a while declaration.
     */
    public void compileWhile() throws IOException
    {
        writeScopeOpener("whileStatement");
        writeInScope(); // while
        jackTokenizer.advance();
        writeInScope(); // (
        jackTokenizer.advance();
        compileExpression();
        writeInScope(); // )
        jackTokenizer.advance();
        writeInScope(); // {
        jackTokenizer.advance();
        compileStatements();
        writeInScope(); // }
        jackTokenizer.advance();
        writeScopeCloser("whileStatement");
    }

    /**class
     * Compiles a return declaration.
     */
    public void compileReturn() throws IOException
    {
        writeScopeOpener("returnStatement");
        writeInScope(); // return
        jackTokenizer.advance();
        if (!(jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == ';'))
        {
            compileExpression();
        }
        writeInScope(); // ;
        writeScopeCloser("returnStatement");
        jackTokenizer.advance();
    }

    /**
     * Compiles an if statement, possibly with a trailing else clause.
     */
    public void compileIf()  throws IOException
    {
        writeScopeOpener("ifStatement");
        writeInScope(); // if
        jackTokenizer.advance();
        writeInScope(); // (
        jackTokenizer.advance();
        compileExpression();
        writeInScope(); // )
        jackTokenizer.advance();
        writeInScope(); // {
        jackTokenizer.advance();
        compileStatements();
        writeInScope(); // }
        jackTokenizer.advance();
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                jackTokenizer.keyWord().equals("else"))
        {
            writeInScope(); // else
            jackTokenizer.advance();
            writeInScope(); // {
            jackTokenizer.advance();
            compileStatements();
            writeInScope(); // }
            jackTokenizer.advance();
        }
        writeScopeCloser("ifStatement");
    }

    /**
     * Compiles an expression.
     */
    public void compileExpression() throws IOException {

        writeScopeOpener("expression");
        compileTerm();

        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                opTable.contains(jackTokenizer.symbol()))
        {
            compileOP();
            compileTerm();
        }
        writeScopeCloser("expression");
    }

    private void compileOP() throws IOException {
        //TODO make sure < is &lt, > is &gt, " is &quot, & is &amp even in const_string
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        JackTokenizer.LexicalElements type = jackTokenizer.tokenType();
        String stringType = jackTokenizer.tokenType().toString();
        if (!stringType.equals("integerConstant") && !stringType.equals("stringConstant"))
        {
            stringType = stringType.toLowerCase();
        }
        switch (jackTokenizer.symbol()) {
            case '<':
                string += "<" + stringType +"> " + "&lt;" + "</" + stringType +">\n";
                break;
            case '>':
                string += "<" + stringType +"> " + "&gt;" + "</" + stringType +">\n";
                break;
            case '\"':
                string += "<" + stringType +"> " + "&quot;" + "</" + stringType +">\n";
                break;
            case '&':
                string += "<" + stringType +"> " + "&amp;" + "</" + stringType +">\n";
                break;
            default:
                string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
        }
        outputFile.write(string);
        jackTokenizer.advance();
    }

    /**
     * Compiles a term. This routine is faced with a slight difficulty when trying to decide between
     * some of the alternative parsing rules. Specifically, if the current token is an identifier, the routine
     * must distinguish between a variable, an array entry, and a subroutine call.
     * A single lookahead token, which may be one of ‘‘[’’, ‘‘(’’, or ‘‘.’’ suffices to
     * distinguish between the three possibilities. Any other token is not part of this term and should not
     * be advanced over.
     */
    public void compileTerm() throws IOException {

        writeScopeOpener("term");
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                (jackTokenizer.symbol() == '(' || jackTokenizer.symbol() == '['))
        {
                writeInScope();
                jackTokenizer.advance();
                compileExpression();
                writeInScope(); // Write ) or ]
                jackTokenizer.advance();
        }
        else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                unaryOpTable.contains(jackTokenizer.symbol()))
        {
            writeInScope();
            jackTokenizer.advance();
            compileTerm();
        }
        else
        {
            if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.IDENTIFIER)
            {
                writeInScope();
                jackTokenizer.advance();
                if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD.SYMBOL &&
                        jackTokenizer.symbol() == '[')
                {
                    writeInScope();
                    jackTokenizer.advance();
                    compileExpression();
                    writeInScope();
                    jackTokenizer.advance();
                }
                else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                        jackTokenizer.symbol() == '(')
                {
                    compileSubroutineCall();
                }
                else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                        jackTokenizer.symbol() == '.')
                {
                    writeInScope(); // .
                    jackTokenizer.advance();
                    writeInScope(); // write name of subroutine
                    jackTokenizer.advance();
                    compileSubroutineCall();
                }
            }
            else
            {
                writeInScope();
                jackTokenizer.advance();
            }
        }
        writeScopeCloser("term");
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     */
    public void compileExpressionList() throws IOException
    {
        // Empty expression list
        writeScopeOpener("expressionList");
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                jackTokenizer.symbol() == ')')
        {
            writeScopeCloser("expressionList");
            return;
        }
        compileExpression();
        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == ',') {
            writeInScope();
            jackTokenizer.advance();
            compileExpression();
        }
        writeScopeCloser("expressionList");
    }
    // Starts after name!!
    public void compileSubroutineCall() throws IOException
    {
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == '(')
        {
            writeInScope(); // (
            jackTokenizer.advance();
            compileExpressionList();
            writeInScope(); // )
        }
        else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == '.')
        {
            writeInScope(); // .
            jackTokenizer.advance();
            writeInScope(); // subroutine name
            jackTokenizer.advance();
            writeInScope(); // (
            jackTokenizer.advance();
            compileExpressionList();
            writeInScope(); // )
        }
        jackTokenizer.advance();
    }

}
