import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
// fix for git
/**
 * Created by yonilip on 5/23/16.
 *
 *
 * recursive top-down parser.
 * drives the parsing process in this project
 *
 * Effects the actual compilation output. Gets its input from a
 * JackTokenizer and emits its parsed structure into an output file/stream. The
 * output is generated by a series of compilexxx() routines, one for every syntactic
 * element xxx of the Jack grammar. The contract between these routines is that each
 * compilexxx() routine should read the syntactic construct xxx from the input,
 * advance() the tokenizer exactly beyond xxx , and output the parsing of xxx . Thus,
 * compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
 * In the first version of the compiler, described in chapter 10, this module emits a
 * structured printout of the code, wrapped in XML tags. In the final version of the
 * compiler, described in chapter 11, this module generates executable VM code. In
 * both cases, the parsing logic and module API are exactly the same.
 *
 */
public class CompilationEngine {


    private BufferedReader inputFile;
    private BufferedWriter outputFile;
    private int indentation;
    JackTokenizer jackTokenizer;

    /**
     * Creates a new compilation engine with the given input and output. The next routine called
     * must be compileClass() .
     * @param inputFile
     * @param outputFile
     */
    public CompilationEngine(BufferedReader inputFile, BufferedWriter outputFile) throws IOException {
        //TODO create the jack tokenizer
        this.inputFile = inputFile;
        this.outputFile = outputFile;
        indentation = 0;

        jackTokenizer = new JackTokenizer(this.inputFile);
        compileClass();
    }

    private void writeScopeOpener(String strToWrite) throws IOException {
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        string += "<" + strToWrite +">\n";
        outputFile.write(string);
        indentation++;
    }

    private void writeScopeCloser(String strToWrite) throws IOException {
        String string = "";
        indentation--;

        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        string += "</" + strToWrite +">\n";
        outputFile.write(string);
    }

    private void writeInScope() throws IOException {
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        JackTokenizer.LexicalElements type = jackTokenizer.tokenType();

        //update string according to token type
        switch (jackTokenizer.tokenType()) {
            case KEYWORD:
                string += "<" + type +"> " + jackTokenizer.keyWord() + "</" + type +">\n";
                break;
            case IDENTIFIER:
                string += "<" + type +"> " + jackTokenizer.identifier() + "</" + type +">\n";
                break;
            case SYMBOL:
                string += "<" + type +"> " + jackTokenizer.symbol() + "</" + type +">\n";
                break;
            case STRING_CONST:
                string += "<" + type +"> " + jackTokenizer.stringVal() + "</" + type +">\n";
                break;
            case INT_CONST:
                string += "<" + type +"> " + jackTokenizer.intVal() + "</" + type +">\n";
                break;
        }
        outputFile.write(string);
    }

    /**
     * Compiles a complete class.
     */
    public void compileClass() throws IOException {
        //TODO starts with <class> and ends with </class> thus whole run should callback here and end here
        writeScopeOpener("class");

        jackTokenizer.hasMoreTokens(); //class
        writeInScope();
        jackTokenizer.hasMoreTokens(); //class name
        writeInScope();
        jackTokenizer.hasMoreTokens(); //open curly
        writeInScope();

        jackTokenizer.hasMoreTokens(); //classVarDec
        if (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field")) {
            writeScopeOpener("classVarDec");
            compileClassVarDec();
            writeScopeCloser("classVarDec");
            jackTokenizer.hasMoreTokens(); // get next for comp
        }
        if (jackTokenizer.keyWord().matches("constructor|function|method")) {
            writeScopeOpener("subroutineDec");
            compileSubroutine();
            writeScopeCloser("subroutineDec");
        }
    }

    /**
     * Compiles a static declaration or a field declaration.
     */
    public void compileClassVarDec() throws IOException {
        while (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field")) {
            writeInScope(); //field/static
            jackTokenizer.hasMoreTokens(); //type
            compileParameterList();
/*
            jackTokenizer.hasMoreTokens(); // varName TODO when more
            writeInScope();

            jackTokenizer.hasMoreTokens(); // next var
            while (jackTokenizer.symbol() == ',') { //TODO make sure this compare works
                writeInScope(); //write the symbol
                jackTokenizer.hasMoreTokens(); //next var
                writeInScope(); //write the var name identifier
                jackTokenizer.hasMoreTokens();
            }*/
            writeInScope(); //write symbol ;
        }
    }

    /**
     * Compiles a complete method, function, or constructor.
     */
    public void compileSubroutine() throws IOException {
        while (jackTokenizer.keyWord().matches("constructor|function|method")) {
            writeInScope(); //constructor|function|method

            jackTokenizer.hasMoreTokens(); //type
            writeInScope();

            jackTokenizer.hasMoreTokens(); //name
            writeInScope();

            jackTokenizer.hasMoreTokens(); // (
            writeInScope();

            //params list
            jackTokenizer.hasMoreTokens();
            writeScopeOpener("parameterList");
            compileParameterList();
            writeScopeCloser("parameterList");

            jackTokenizer.hasMoreTokens(); // ) TODO if there is bug maybe del this and find similar
            writeInScope();

            writeScopeOpener("subroutineBody");
            jackTokenizer.hasMoreTokens(); // {
            writeInScope();

            jackTokenizer.hasMoreTokens();
            compileVarDec(); //scope opener in here


            compileStatements();






            jackTokenizer.hasMoreTokens(); // }
            writeInScope();
            writeScopeCloser("subroutineBody");

        }
    }

    /**
     * Compiles a (possibly empty) parameter list, not including the enclosing ‘‘ () ’’.
     */
    public void compileParameterList() throws IOException {
        //jackTokenizer.hasMoreTokens(); //type
        if (jackTokenizer.keyWord().matches("int|char|boolean") ||
                jackTokenizer.tokenType().equals(JackTokenizer.LexicalElements.IDENTIFIER)) { //TODO check if last comparison works
            writeInScope();

            jackTokenizer.hasMoreTokens(); // varName TODO when more
            writeInScope();

            jackTokenizer.hasMoreTokens(); // next var
            while (jackTokenizer.symbol() == ',') { //TODO make sure this compare works
                writeInScope(); //write the symbol
                jackTokenizer.hasMoreTokens(); //next var
                writeInScope(); //write the var name identifier
                jackTokenizer.hasMoreTokens();
            }
        }
    }

    /**
     * Compiles a var declaration.
     */
    public void compileVarDec() throws IOException {
        if (jackTokenizer.keyWord().matches("int|char|boolean") ||
                jackTokenizer.tokenType().equals(JackTokenizer.LexicalElements.IDENTIFIER)) { //TODO check if last comparison works
            writeScopeOpener("varDec");

            writeInScope();

            jackTokenizer.hasMoreTokens(); // varName TODO when more
            writeInScope();

            jackTokenizer.hasMoreTokens(); // next var
            while (jackTokenizer.symbol() == ',') { //TODO make sure this compare works
                writeInScope(); //write the symbol
                jackTokenizer.hasMoreTokens(); //next var
                writeInScope(); //write the var name identifier
                jackTokenizer.hasMoreTokens();
            }
            writeScopeCloser("varDec");
        }
    }

    /**
     * Compiles a sequence of statements, not including the enclosing ‘‘{}’’.
     */
    public void compileStatements() throws IOException {
        writeScopeOpener("statements");
        while (jackTokenizer.keyWord().matches("let|if|while|do|return")) {

            if (jackTokenizer.keyWord().equals("let")) {
                writeScopeOpener("letStatement");
                writeInScope(); //write the keyword
                jackTokenizer.hasMoreTokens();
                writeInScope(); // write varName
                jackTokenizer.hasMoreTokens();
                if (jackTokenizer.symbol() == '[') {
                    writeInScope();
                    compileExpression();

                    jackTokenizer.hasMoreTokens();
                    writeInScope(); // ]
                }


                writeScopeCloser("letStatement");
            } else if (jackTokenizer.keyWord().equals("if")) {
                writeScopeOpener("ifStatement");
                //TODO
                writeScopeCloser("ifStatement");
            } else if (jackTokenizer.keyWord().equals("while")) {
                writeScopeOpener("whileStatement");
                //TODO
                writeScopeCloser("whileStatement");
            } else if (jackTokenizer.keyWord().equals("do")) {
                writeScopeOpener("doStatement");
                //TODO
                writeScopeCloser("doStatement");
            } else if (jackTokenizer.keyWord().equals("return")) {
                writeScopeOpener("returnStatement");
                //TODO
                writeScopeCloser("returnStatement");
            }
        }
        writeScopeCloser("statements");
    }

    /**
     * Compiles a do declaration.
     */
    public void compileDo() {

    }

    /**
     * Compiles a let declaration.
     */
    public void compileLet() {

    }

    /**
     * Compiles a while declaration.
     */
    public void compileWhile() {

    }

    /**class
     * Compiles a return declaration.
     */
    public void compileReturn() {

    }

    /**
     * Compiles an if statement, possibly with a trailing else clause.
     */
    public void compileIf() {

    }

    /**
     * Compiles an expression.
     */
    public void compileExpression() throws IOException {

        writeScopeOpener("expression");
        compileTerm();

        while (JackTokenizer.symbolSet.contains(jackTokenizer.symbol())) {
            compileOP();
            compileTerm();
        }
        writeScopeCloser("expression");
    }

    private void compileOP() throws IOException {
        //TODO make sure < is &lt, > is &gt, " is &quot, & is &amp even in const_string
        String string = "";

        //Add the indentation tabs
        for (int i = 0; i < indentation; i++) {
            string += "\t";
        }
        JackTokenizer.LexicalElements type = jackTokenizer.tokenType();

        switch (jackTokenizer.symbol()) {
            case '<':
                string += "<" + type +"> " + "&lt" + "</" + type +">\n";
                break;
            case '>':
                string += "<" + type +"> " + "&gt" + "</" + type +">\n";
                break;
            case '\"':
                string += "<" + type +"> " + "&quot" + "</" + type +">\n";
                break;
            case '&':
                string += "<" + type +"> " + "&amp" + "</" + type +">\n";
                break;
            default:
                string += "<" + type +"> " + jackTokenizer.symbol() + "</" + type +">\n";
        }
        outputFile.write(string);
    }

    /**
     * Compiles a term. This routine is faced with a slight difficulty when trying to decide between
     * some of the alternative parsing rules. Specifically, if the current token is an identifier, the routine
     * must distinguish between a variable, an array entry, and a subroutine call.
     * A single lookahead token, which may be one of ‘‘[’’, ‘‘(’’, or ‘‘.’’ suffices to
     * distinguish between the three possibilities. Any other token is not part of this term and should not
     * be advanced over.
     */
    public void compileTerm() throws IOException {
        //most cases are calling writeInScope except for subroutineCall, varName with [] and unaryOp term
        if (jackTokenizer.symbol() == '-' || jackTokenizer.symbol() == '~') {
            writeInScope();
            compileTerm();
        }
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     */
    public void compileExpressionList() throws IOException {
        compileExpression();
        jackTokenizer.hasMoreTokens();
        while (jackTokenizer.symbol() == ',') {
            writeInScope();
            compileExpression();
            jackTokenizer.hasMoreTokens();
        }
    }

}
