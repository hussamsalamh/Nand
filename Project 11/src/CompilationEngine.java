import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashSet;
// fix for git
/**
 * Created by yonilip on 5/23/16.
 *
 *
 * recursive top-down parser.
 * drives the parsing process in this project
 *
 * Effects the actual compilation output. Gets its input from a
 * JackTokenizer and emits its parsed structure into an output file/stream. The
 * output is generated by a series of compilexxx() routines, one for every syntactic
 * element xxx of the Jack grammar. The contract between these routines is that each
 * compilexxx() routine should read the syntactic construct xxx from the input,
 * advance() the tokenizer exactly beyond xxx , and output the parsing of xxx . Thus,
 * compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
 * In the first version of the compiler, described in chapter 10, this module emits a
 * structured printout of the code, wrapped in XML tags. In the final version of the
 * compiler, described in chapter 11, this module generates executable VM code. In
 * both cases, the parsing logic and module API are exactly the same.
 *
 */
public class CompilationEngine {
    //TODO: Decide about /t - make sure it's ok

    private BufferedReader inputFile;
    private VMWriter vmWriter;
    private BufferedWriter outputFile;
    private int indentation;
    JackTokenizer jackTokenizer;
    SymbolTable st = new SymbolTable();

    private static final HashSet<Character> opTable = new HashSet<Character>() {{
        add('+');
        add('-');
        add('*');
        add('/');
        add('&');
        add('|');
        add('<');
        add('>');
        add('=');
    }};
    private static final HashSet<Character> unaryOpTable = new HashSet<Character>() {{
        add('-');
        add('~');
    }};




    /**
     * Creates a new compilation engine with the given input and output. The next routine called
     * must be compileClass() .
     * @param inputFile
     * @param outputFile
     */
    public CompilationEngine(BufferedReader inputFile, BufferedWriter outputFile) throws IOException {
        this.inputFile = inputFile;
        this.vmWriter = new VMWriter(outputFile);
        indentation = 0;

        jackTokenizer = new JackTokenizer(this.inputFile);
        compileClass();
    }





    /**
     * Compiles a complete class.
     */
    public void compileClass() throws IOException {

        jackTokenizer.advance(); // class
        jackTokenizer.advance(); //class name
        st.setClassName(jackTokenizer.identifier());
        st.classDefinition = true;
        jackTokenizer.advance(); // {


        jackTokenizer.advance(); //classVarDec
        while( jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field")))
        {
            compileClassVarDec(); // Finishes at ;
            jackTokenizer.advance(); // get next for comp
        }
        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                jackTokenizer.keyWord().matches("constructor|function|method"))
        {
            compileSubroutine(); // Ends at next subroutine if exists, otherwise at }
        }
    }

    /**
     * Compiles a static declaration or a field declaration.
     */
    public void compileClassVarDec() throws IOException {
        // Starts at field/static if exists
        if (jackTokenizer.keyWord().equals("static") || jackTokenizer.keyWord().equals("field"))
        {
            SymbolTable.kind currKind;
            if (jackTokenizer.keyWord().equals("static"))
            {
                currKind = SymbolTable.kind.STATIC;
            }
            else
            {
                currKind = SymbolTable.kind.FIELD;
            }
            jackTokenizer.advance(); // Move to type
            String type;
            if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD)
            {
                type = jackTokenizer.keyWord().toString();
            }
            else
            {
                type = jackTokenizer.identifier().toString();
            }
            jackTokenizer.advance(); // Move to varName
            String name = jackTokenizer.identifier().toString();
            st.Define(name, type, currKind);
            jackTokenizer.advance(); // Moves to beginning of var list if exists
            compileVarList(type, currKind); // Compile var list if necessary
        }
    }

    private void pointToThis() throws IOException
    {
        vmWriter.writePush(VMWriter.SEGMENT.ARGUMENT, 0);
        vmWriter.writePop(VMWriter.SEGMENT.POINTER, 0);
    }
    /**
     * Compiles a complete method, function, or constructor.
     */
    public void compileSubroutine() throws IOException {
        // Starts at keyword constructor / function / method if subroutine
        if (jackTokenizer.keyWord().matches("constructor|function|method")) {
            st.startSubroutine(); // clear symbol table
            if (jackTokenizer.keyWord().equals("method"))
            {
                st.numArg += 1; // It's a method so it has more arguments
            }
            String subRoutinetype = jackTokenizer.keyWord();
            jackTokenizer.advance(); // Moves to void or type


            jackTokenizer.advance(); //name
            String subroutineName = jackTokenizer.identifier();

            jackTokenizer.advance(); // (

            //params list
            jackTokenizer.advance(); // Gors to beginning of parameter list
            compileParameterList(); // Ends at )

            String funcName = st.className + "." + subroutineName;
            jackTokenizer.advance(); // {
            jackTokenizer.advance(); // Goes to var if exists
            while(jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD && jackTokenizer.keyWord().equals("var"))
            {
                compileVarDec();
            }
            int numLocals = st.VarCount(SymbolTable.kind.VAR);
            vmWriter.writeFunction(funcName, numLocals);
            if (subRoutinetype.equals("constructor"))
            {
                int numFields = st.VarCount(SymbolTable.kind.FIELD);
                vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, numFields);
                vmWriter.writeCall("Memory.alloc", 1);
                vmWriter.writePop(VMWriter.SEGMENT.POINTER, 0);
            }
            if (subRoutinetype.equals("method"))
            {
                pointToThis(); // If it's a method, start by pointing to this
            }
            compileStatements();
            jackTokenizer.advance();

        }
    }

    public void compileVarList(String type, SymbolTable.kind varKind) throws IOException
    {
        while (jackTokenizer.symbol() == ',') {
            jackTokenizer.advance(); //next var
            String name = jackTokenizer.identifier();
            st.Define(name, type, varKind);
            jackTokenizer.advance();
        }
    }

    /**
     * Compiles a (possibly empty) parameter list, not including the enclosing ‘‘ () ’’.
     */
    public int compileParameterList() throws IOException
    {
        int numParameters = 0;
        // Starts with var type
        // Parameter list is empty
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&  jackTokenizer.symbol() == ')')
        {
            return numParameters;
        }
        String type;
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD)
        {
            type = jackTokenizer.keyWord().toString();
        }
        else
        {
            type = jackTokenizer.identifier().toString();
        }
        jackTokenizer.advance(); // goes to var name
        String name = jackTokenizer.identifier();
        st.Define(name, type, SymbolTable.kind.ARG);
        jackTokenizer.advance(); // Goes to , if exists
        numParameters += 1;
        while (jackTokenizer.symbol() == ',')
        {
            jackTokenizer.advance(); // Goes to var type
            if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD)
            {
                type = jackTokenizer.keyWord().toString();
            }
            else
            {
                type = jackTokenizer.identifier().toString();
            }
            jackTokenizer.advance(); // Goes to var name
            name = jackTokenizer.identifier();
            st.Define(name, type, SymbolTable.kind.ARG);

            jackTokenizer.advance(); // Goes to next ,
            numParameters += 1;
        }
        return numParameters;
    }


    /**
     * Compiles a var declaration.
     */
    public void compileVarDec() throws IOException
    {
        // Starts with var if there is a variable declaration
        if (jackTokenizer.tokenType().equals(JackTokenizer.LexicalElements.KEYWORD)
                && jackTokenizer.keyWord().equals("var")) {
            jackTokenizer.advance(); // Goes to type
            String type;
            if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD)
            {
                type = jackTokenizer.keyWord().toString();
            }
            else
            {
                type = jackTokenizer.identifier().toString();
            }
            jackTokenizer.advance(); // Goes to varName
            String name = jackTokenizer.identifier();
            st.Define(name, type, SymbolTable.kind.VAR);

            jackTokenizer.advance(); // Goes to beginning of var list
            compileVarList(type, SymbolTable.kind.VAR); // compiles var list if necessary, ends at ;
            jackTokenizer.advance();
        }
    }

    /**
     * Compiles a sequence of statements, not including the enclosing ‘‘{}’’.
     */
    public void compileStatements() throws IOException {

        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                jackTokenizer.keyWord().matches("let|if|while|do|return"))
        {

            if (jackTokenizer.keyWord().equals("let"))
            {
                compileLet();
            }
            else if (jackTokenizer.keyWord().equals("if")) {
                compileIf();
            }
            else if (jackTokenizer.keyWord().equals("while"))
            {
                compileWhile();
            }
            else if (jackTokenizer.keyWord().equals("do"))
            {
                compileDo();
            }
            else if (jackTokenizer.keyWord().equals("return")) {
                compileReturn();
            }
        }
    }

    /**
     * Compiles a do declaration.
     */
    public void compileDo() throws IOException
    {
        // Starts at do
        jackTokenizer.advance(); // Moves to function or variable name
        jackTokenizer.peek(); // Peek at next

        String subRoutineName = jackTokenizer.identifier();
        jackTokenizer.advance(); // Move to . or (
        String typeOf = st.TypeOf(subRoutineName); // Check if identifier was subroutine
        if (typeOf != null) // if not, it was a variable, and its type is needed to call subroutine properly
        {
            SymbolTable.kind currKind = st.KindOf(subRoutineName);
            switch (currKind)
            {
                case VAR:
                    vmWriter.writePush(VMWriter.SEGMENT.LOCAL, st.IndexOf(subRoutineName));
                    break;
                case FIELD:
                    vmWriter.writePush(VMWriter.SEGMENT.THIS, st.IndexOf(subRoutineName));
                    break;
                case STATIC:
                    vmWriter.writePush(VMWriter.SEGMENT.STATIC, st.IndexOf(subRoutineName));
                    break;
                default:
                    System.out.println("wtf?");
                    break;
            }
        }
        compileSubroutineCall(subRoutineName); // Moves to ; after compilation
        vmWriter.writePop(VMWriter.SEGMENT.TEMP, 0);
        jackTokenizer.advance(); // Advances to next line
    }

    /**
     * Compiles a let declaration.
     */
    public void compileLet() throws IOException {
        // Starts with let
        jackTokenizer.advance(); // Goes to var name

        String varName = jackTokenizer.identifier();
        jackTokenizer.advance(); // Goes to type
        boolean isArray = false;
        SymbolTable.kind currKind = st.KindOf(varName); // Check which segment the variable is on
        if (jackTokenizer.symbol() == '[') // Check if is array
        {
            // Puts it on stack ahead of time (conforms with Jack Compiler)
            isArray = true;
            switch (currKind)
            {
                case VAR:
                    vmWriter.writePush(VMWriter.SEGMENT.LOCAL, st.IndexOf(varName));
                    break;
                case FIELD:
                    vmWriter.writePush(VMWriter.SEGMENT.THIS, st.IndexOf(varName));
                    break;
                case STATIC:
                    vmWriter.writePush(VMWriter.SEGMENT.STATIC, st.IndexOf(varName));
                    break;
                case ARG:
                    vmWriter.writePush(VMWriter.SEGMENT.ARGUMENT, st.IndexOf(varName));
                    break;
                default:
                    System.out.println("wtf?");
                    break;
            }

            jackTokenizer.advance();
            compileExpression(); // Puts expression
            vmWriter.writeArithmetic(VMWriter.COMMAND.ADD); // Puts base + index at top of stack
            jackTokenizer.advance(); // Goes to = after ]
        }
        jackTokenizer.advance(); // Go to expression after =
        compileExpression(); // Compiles Expression
        // If it was an array put base in the that segment
        if (isArray)
        {
            vmWriter.writePop(VMWriter.SEGMENT.TEMP, 0);
            vmWriter.writePop(VMWriter.SEGMENT.POINTER, 1);
            vmWriter.writePush(VMWriter.SEGMENT.TEMP, 0);
            vmWriter.writePop(VMWriter.SEGMENT.THAT, 0);
        }
        // Otherwise proceed as usual
        else
        {
            switch (currKind)
            {
                case VAR:
                    vmWriter.writePop(VMWriter.SEGMENT.LOCAL, st.IndexOf(varName));
                    break;
                case FIELD:
                    vmWriter.writePop(VMWriter.SEGMENT.THIS, st.IndexOf(varName));
                    break;
                case STATIC:
                    vmWriter.writePop(VMWriter.SEGMENT.STATIC, st.IndexOf(varName));
                    break;
                case ARG:
                    vmWriter.writePop(VMWriter.SEGMENT.ARGUMENT, st.IndexOf(varName));
                default:
                    // This is ok, class name is not supposed to be found when calling function
                    break;
            }
        }
        jackTokenizer.advance(); // Pass ; to nxt line
    }

    /**
     * Compiles a while declaration.
     */
    public void compileWhile() throws IOException
    {
        // Keyword while is first
        jackTokenizer.advance(); // Go to (
        jackTokenizer.advance(); // Go to expression
        int numFlow = st.getNumControlFlow(); // Get number of flow control
        st.incrementFlow(); // Increment

        // Logic is written according to the book (which is a bit counterintuitive but works
        /*
         Compiles ~cond
         */
        vmWriter.writeLabel("flow" + numFlow + "F");
        compileExpression();
        vmWriter.writeArithmetic(VMWriter.COMMAND.NOT);

        // If true jump to end (it's the opposite)
        vmWriter.writeIf("flow" + numFlow + "T");
        jackTokenizer.advance(); // Goes to {
        jackTokenizer.advance(); // Goes to statements
        compileStatements();

        vmWriter.writeGoto("flow" + numFlow + "F");
        jackTokenizer.advance();
        vmWriter.writeLabel("flow" + numFlow + "T");
    }

    /**class
     * Compiles a return declaration.
     */
    public void compileReturn() throws IOException
    {
        // Starts at return
        boolean isVoid = true;
        jackTokenizer.advance(); // Goes to ; or return value
        if (!(jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == ';'))
        {
            // If it's not ;, then method is not void, compile expression and put on top of stack
            isVoid = false;
            compileExpression(); // End at ;
        }
        // If void, put 0 on top of stack and return
        if  (isVoid)
        {
            vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, 0);
        }
        vmWriter.writeReturn();
        jackTokenizer.advance(); // Go to end of statement
    }

    /**
     * Compiles an if statement, possibly with a trailing else clause.
     */
    public void compileIf()  throws IOException
    {
        // Starts with if keyword

        jackTokenizer.advance(); // Goes to (

        jackTokenizer.advance(); // Goes to start of condition
        compileExpression(); // Compile Condition, ends with )

        // VM flow according to book, (for if)
        vmWriter.writeArithmetic(VMWriter.COMMAND.NOT);
        int numFlow = st.getNumControlFlow();
        st.incrementFlow();

        vmWriter.writeIf("flow" + numFlow + "F");

        jackTokenizer.advance(); // Goes to {
        jackTokenizer.advance(); // Goes to statement

        compileStatements(); // Goes to }
        vmWriter.writeGoto("flow" + numFlow + "T");

        jackTokenizer.advance(); // Goes to else
        vmWriter.writeLabel("flow" + numFlow + "F");
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD &&
                jackTokenizer.keyWord().equals("else"))
        {
            jackTokenizer.advance(); // Goes to {
            jackTokenizer.advance(); // Goes to statements

            compileStatements(); // Goes to }

            jackTokenizer.advance(); // Go to next part of statement
        }
        vmWriter.writeLabel("flow" + numFlow + "T");
    }

    /**
     * Compiles an expression.
     */
    public void compileExpression() throws IOException
    {
        // Starts with term
        compileTerm(); // Ends at end of expression of op

        // do (op term)*
        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                opTable.contains(jackTokenizer.symbol()))
        {
            VMWriter.COMMAND op = compileOP();
            compileTerm();
            vmWriter.writeArithmetic(op);
        }
    }

    private VMWriter.COMMAND compileOP() throws IOException {
        String string = "";


        JackTokenizer.LexicalElements type = jackTokenizer.tokenType();
        String stringType = jackTokenizer.tokenType().toString();
        if (!stringType.equals("integerConstant") && !stringType.equals("stringConstant"))
        {
            stringType = stringType.toLowerCase();
        }
        VMWriter.COMMAND currCommand = null;
        switch (jackTokenizer.symbol()) {
            case '<':
             //   string += "<" + stringType +"> " + "&lt;" + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.LT;
                break;
            case '>':
             //   string += "<" + stringType +"> " + "&gt;" + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.GT;
                break;
            case '\"':
                //TODO: look into this
            //    string += "<" + stringType +"> " + "&quot;" + "</" + stringType +">\n";
                break;
            case '&':
            //    string += "<" + stringType +"> " + "&amp;" + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.AND;
                break;
            case '*':
            //    string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.MULT;
                break;
            case '|':
           //     string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.OR;
                break;
            case '/':
         //       string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.DIVIDE;
                break;
            case  '=':
          //      string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.EQ;
                break;
            case '-':
         //       string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.SUB;
                break;
            case '+':
         //       string += "<" + stringType +"> " + jackTokenizer.symbol() + "</" + stringType +">\n";
                currCommand = VMWriter.COMMAND.ADD;
                break;
            default:
                System.out.println("Fuck my life");
        }
        jackTokenizer.advance();
        return currCommand;
    }

    /**
     * Compiles a term. This routine is faced with a slight difficulty when trying to decide between
     * some of the alternative parsing rules. Specifically, if the current token is an identifier, the routine
     * must distinguish between a variable, an array entry, and a subroutine call.
     * A single lookahead token, which may be one of ‘‘[’’, ‘‘(’’, or ‘‘.’’ suffices to
     * distinguish between the three possibilities. Any other token is not part of this term and should not
     * be advanced over.
     */
    public void compileTerm() throws IOException
    {
        // Start with term
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                (jackTokenizer.symbol() == '(' || jackTokenizer.symbol() == '['))
        {
            jackTokenizer.advance(); // Move to expression
            compileExpression(); // Moves at end to )
            jackTokenizer.advance();
        }
        else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                unaryOpTable.contains(jackTokenizer.symbol()))
        {
            Character unaryOp = jackTokenizer.symbol();
            jackTokenizer.advance(); // Moves to term
            compileTerm(); // Put term on stack
            switch (unaryOp) // Perform unary operation
            {
                case ('-'):
                    vmWriter.writeArithmetic(VMWriter.COMMAND.NEG);
                    break;
                case ('~'):
                    vmWriter.writeArithmetic(VMWriter.COMMAND.NOT);
                    break;
                default:
                    break;
            }

        }
        else
        {
            if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.IDENTIFIER)
            {
                jackTokenizer.peek();
                String varName = jackTokenizer.identifier();
                SymbolTable.kind currKind = st.KindOf(varName);
                switch (currKind)
                {
                    case VAR:
                        vmWriter.writePush(VMWriter.SEGMENT.LOCAL, st.IndexOf(varName));
                        break;
                    case FIELD:
                        vmWriter.writePush(VMWriter.SEGMENT.THIS, st.IndexOf(varName));
                        break;
                    case STATIC:
                        vmWriter.writePush(VMWriter.SEGMENT.STATIC, st.IndexOf(varName));
                        break;
                    case ARG:
                        vmWriter.writePush(VMWriter.SEGMENT.ARGUMENT, st.IndexOf(varName));
                        break;
                    default:
                        // Class name not supposed to be found
                        break;
                }
                jackTokenizer.advance(); // Move to next, handles arrays
                if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                        jackTokenizer.symbol() == '[')
                {
                    jackTokenizer.advance(); // Moves to expression in brackets
                    compileExpression(); // Compiles expression in brackets and moves to ]


                    vmWriter.writeArithmetic(VMWriter.COMMAND.ADD); // Put base + index on top of stack
                    /*
                    Moves arrayVar[k] to that
                     */
                    vmWriter.writePop(VMWriter.SEGMENT.POINTER, 1);
                    vmWriter.writePush(VMWriter.SEGMENT.THAT, 0);
                    jackTokenizer.advance(); // Move to end bracket
                }
                // Checks if subroutine call
                else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                        jackTokenizer.symbol() == '(' || jackTokenizer.symbol() == '.')
                {
                    compileSubroutineCall(varName);
                }

            }
            else
            {
                // Checks special cases
                if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.KEYWORD)
                {
                    if (jackTokenizer.keyWord().equals("this"))
                    {
                        vmWriter.writePush(VMWriter.SEGMENT.POINTER, 0);
                    }
                    else if (jackTokenizer.keyWord().equals("true"))
                    {
                        vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, 1);
                        vmWriter.writeArithmetic(VMWriter.COMMAND.NEG);

                    }
                    else if (jackTokenizer.keyWord().equals("false") || jackTokenizer.keyWord().equals("null"))
                    {
                        vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, 0);
                    }
                }
                else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.integerConstant)
                {
                    vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, jackTokenizer.intVal());
                }
                // If string allocate memory and append char
                else
                {
                    String constString = jackTokenizer.stringVal();
                    int stringLength = constString.length();
                    // Put pointer to allocated string on top of stack
                    vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, stringLength);
                    vmWriter.writeCall("String.new", 1);
                    // Append chars
                    for (int i =0; i < stringLength; i++)
                    {
                        vmWriter.writePush(VMWriter.SEGMENT.CONSTANT, constString.charAt(i));
                        vmWriter.writeCall("String.appendChar", 2);
                    }
                }
                jackTokenizer.advance(); // Pass " to end of term
            }
        }
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     */
    public int compileExpressionList() throws IOException
    {
        // Start of expression list
        int numExpressions = 0;
        // Empty expression list
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL &&
                jackTokenizer.symbol() == ')')
        {
            return numExpressions;
        }
        compileExpression();
        numExpressions += 1;
        while (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == ',') {
            jackTokenizer.advance(); // Move to expression after ,
            compileExpression(); // Compile expression to top of stack and go to next , or ;
            numExpressions +=1;
        }
        return numExpressions; // Return nmber of expressions in list
    }

    public void compileSubroutineCall(String routineName) throws IOException
    {
        boolean isMethod = false;
        String subroutineName = "";
        int numParams = 0;
        // Checks what type of subroutine call
        if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == '(')
        {
            // If a subroutine was called without . before, it's a method
            isMethod = true;
            // Change name accordingly
            subroutineName = st.className + "." +  routineName;
            // Move to expressionlist in subroutine
            jackTokenizer.advance();
            // This is the this of the class
            vmWriter.writePush(VMWriter.SEGMENT.POINTER, 0);
            numParams = compileExpressionList(); // Moves to )
        }
        else if (jackTokenizer.tokenType() == JackTokenizer.LexicalElements.SYMBOL && jackTokenizer.symbol() == '.')
        {
            // If there is a . it could be a method
            isMethod = true;
            jackTokenizer.advance(); // Move to subroutine name

            String typeOf = st.TypeOf(routineName);

            // If type was not found, it's not a method
            if (typeOf == null)
            {
                isMethod = false;
                typeOf = routineName;
            }
            subroutineName = typeOf + "." + jackTokenizer.identifier();
            jackTokenizer.advance(); // Move to (

            jackTokenizer.advance(); // Move to expression expression list
            numParams = compileExpressionList(); // Compile expression list and move to )
        }
        // If it's a method, take into account that first argument is method that is calling the method
        if (isMethod)
        {
            numParams += 1;
        }
        // Call the subroutine name with the correct number of parameters
        vmWriter.writeCall(subroutineName, numParams);
        jackTokenizer.advance(); // Move past )
    }

}
